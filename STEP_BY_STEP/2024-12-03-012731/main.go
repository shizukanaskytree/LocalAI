package main

import (
	"os"
	"os/signal"
	"syscall"
)

// 这段 Go 代码展示了一个简单的程序，该程序会一直运行，直到接收到一个信号（例如按下 Ctrl+C）才会终止。以下是对代码的逐步解释：

// 导入包
// os: 提供与操作系统交互的功能，包括处理信号和退出程序。
// os/signal: 提供处理来自操作系统的信号的功能。
// syscall: 提供对底层操作系统原语的接口，包括信号常量如 SIGTERM。

// 主函数
// 信号处理:
// 启动了一个 goroutine 来处理操作系统信号。
// c := make(chan os.Signal, 1): 创建一个信号通道 c，用于接收操作系统信号。通道的缓冲区大小为1，确保可以容纳一个信号。
// signal.Notify(c, os.Interrupt, syscall.SIGTERM): 配置通道 c 以接收 os.Interrupt（由 Ctrl+C 触发）和 syscall.SIGTERM 信号。
// <-c: goroutine 等待从通道 c 接收到信号。
// os.Exit(1): 当接收到信号时，程序以状态码1退出。

// 主程序逻辑:
// println("Program is running. Press Ctrl+C to exit."): 打印一条消息，指示程序正在运行。
// select {}: 一个空的 select 语句会无限期地阻塞主 goroutine。这使得程序会一直运行，直到接收到信号。
// 总结
// 这个程序设置了一个简单的机制来优雅地处理终止信号。程序会一直运行，打印一条消息到控制台，当接收到中断信号时退出，展示了 Go 中基本的信号处理方法。

func main() {
	// 解释
	// c := make(chan os.Signal, 1)
	// signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	// <-c

	// 这段代码是用来处理操作系统信号的，通常用于在程序中优雅地响应中断或终止信号。以下是对每一行代码的详细解释：

	// 代码解释
	// c := make(chan os.Signal, 1):
	// 创建一个信号通道 c，用于接收操作系统信号。
	// make(chan os.Signal, 1) 使用 Go 的内置 make 函数创建一个通道，类型为 os.Signal，缓冲区大小为 1。这意味着通道可以在不阻塞发送方的情况下存储一个信号。

	// signal.Notify(c, os.Interrupt, syscall.SIGTERM):
	// 将特定的操作系统信号转发到通道 c。

	// 如何理解"将特定的操作系统信号转发到通道 c"?
	// 在 Go 语言中，“将特定的操作系统信号转发到通道 c” 的意思是，当操作系统发送特定信号（例如 os.Interrupt 或 syscall.SIGTERM）到程序时，这些信号会被捕获并发送到预先定义的通道 c。这使得程序可以通过监听通道 c 来检测这些信号的到来，并做出相应的处理。
	// 具体理解
	// 信号捕获:
	// 操作系统信号是由操作系统发送给进程的事件通知，通常用于通知进程某些事件的发生，如用户中断、终止请求等。
	// 通道 c:
	// 通道 c 是一个用于传递 os.Signal 类型数据的通信机制。通过 make(chan os.Signal, 1) 创建的通道可以存储一个信号。
	// 信号转发:
	// 使用 signal.Notify(c, os.Interrupt, syscall.SIGTERM) 函数，程序将配置通道 c 来接收特定的信号。
	// 当这些信号到达时，signal.Notify 会自动将信号发送到通道 c。
	// 响应机制:
	// 程序可以通过 <-c 来从通道中接收信号。当信号被转发到通道时，<-c 会解除阻塞，程序可以执行相应的处理逻辑，如清理资源或优雅地退出。
	// 这种机制允许程序在不阻塞主线程的情况下，优雅地处理外部信号，确保在接收到中断或终止请求时能够进行必要的清理或保存操作。

	// signal.Notify 函数配置通道 c 以接收 os.Interrupt（通常由用户在终端按下 Ctrl+C 产生）和 syscall.SIGTERM（终止信号）信号。
	// 当这些信号到达时，它们会被发送到通道 c。

	// <-c:
	// 从通道 c 中接收数据。
	// 这是一个阻塞操作，意味着如果通道中没有数据，程序会在此等待，直到有信号被发送到通道 c。
	// 一旦接收到信号，接收操作完成，程序会继续执行后续代码。

	// 使用场景
	// 这段代码通常用于实现信号处理，使程序能够在接收到特定信号时优雅地退出或执行其他清理操作。通过这种方式，程序可以在不阻塞主线程的情况下监听操作系统信号，并在需要时做出响应。

	// 捕获信号
	go func() {
		// 在 Go 语言中，c := make(chan os.Signal, 1) 这行代码的作用是创建一个用于接收操作系统信号的通道。以下是对这行代码的详细解释：
		// 代码解释
		// make(chan os.Signal, 1):
		// make: Go 中的内置函数，用于创建切片、映射和通道。
		// chan os.Signal: 声明一个通道类型，该通道专门用于传递 os.Signal 类型的值。os.Signal 是一个接口，表示从操作系统接收到的信号。
		// 1: 指定通道的缓冲区大小为 1。这意味着通道可以在不阻塞发送方的情况下存储一个信号。
		// c :=:
		// 该语法用于声明并初始化变量 c，将其设为新创建的信号通道。
		// 使用场景
		// 信号处理: 这个通道用于在程序中异步接收操作系统信号（例如中断信号 os.Interrupt 或终止信号 syscall.SIGTERM），以便程序可以在接收到这些信号时执行特定的处理逻辑（如优雅地退出）。
		// 通过这种方式，程序可以在不阻塞主线程的情况下监听操作系统信号，并在需要时做出响应。
		c := make(chan os.Signal, 1)

		// 在 Go 语言中，signal.Notify(c, os.Interrupt, syscall.SIGTERM) 这一行代码用于设置信号通知，以便程序可以响应特定的操作系统信号。以下是对这行代码的详细解释：
		// 代码解释
		// signal.Notify:
		// 这是 Go 的 os/signal 包中的一个函数，用于将特定的操作系统信号转发到一个通道。
		// 通过调用 signal.Notify，程序可以在接收到指定信号时，通过通道 c 接收这些信号。
		// c:
		// 这是一个通道，用于接收信号。之前已经通过 make(chan os.Signal, 1) 创建。
		// 当指定的信号到达时，它们会被发送到这个通道。
		// os.Interrupt:
		// 代表中断信号（通常是用户在终端按下 Ctrl+C 时产生）。
		// 使用这个信号可以让程序在用户请求中断时执行特定的操作（如清理资源、优雅地退出等）。
		// syscall.SIGTERM:
		// 代表终止信号，是一种请求程序终止的信号。
		// 通常用于系统或其他程序请求当前程序退出时。
		// 使用场景
		// 通过 signal.Notify(c, os.Interrupt, syscall.SIGTERM)，程序可以在不阻塞主线程的情况下监听这些信号，并在接收到信号时，通过通道 c 做出响应。这种机制常用于需要优雅关闭的程序，以便在退出前执行必要的清理操作。
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)

		// 在 Go 语言中，<-c 是从通道 c 中接收数据的操作。以下是对这行代码的详细解释：

		// 代码解释
		// <-c:
		// 这是一个接收操作，用于从通道 c 中接收数据。
		// 当通道 c 中有数据可用时，接收操作会获取该数据并继续执行后续代码。
		// 如果通道 c 中没有数据，接收操作会阻塞当前 goroutine，直到有数据可用。
		// 使用场景
		// 在这段代码中，<-c 用于等待操作系统信号的到来。具体来说：

		// 当 signal.Notify(c, os.Interrupt, syscall.SIGTERM) 将 os.Interrupt 或 syscall.SIGTERM 信号发送到通道 c 时，<-c 会接收到这个信号。
		// 这会导致接收操作完成，程序执行 os.Exit(1)，以状态码 1 退出程序。
		// 这种机制常用于实现信号处理，使程序能够在接收到特定信号时优雅地退出或执行其他清理操作。
		<-c
		os.Exit(1)
	}()

	// 主程序逻辑
	println("Program is running. Press Ctrl+C to exit.")
	select {} // 阻塞主线程
}
